# Implementation Plan: User Authentication System

**Feature ID:** 001-user-authentication-system
**Created:** 2025-10-12
**Status:** draft

---

## Tech Stack Compliance Report
<!-- Auto-generated by SpecTest tech stack validation -->

### ✅ Approved Technologies (from tech-stack.md v1.0.0)

All technologies for this feature are APPROVED in `/memory/tech-stack.md`:

- **TypeScript 5.x** - Language (strict mode)
- **React Router v7** - Frontend framework (framework mode, programmatic routing)
- **Express** - Backend framework (REST APIs)
- **PostgreSQL 17** - Database (via Neon)
- **postgres npm package** - Database client (automatic case conversion)
- **uuid (uuidv7)** - Primary key generation
- **Zod** - Runtime validation (frontend UX + backend security)
- **@node-rs/argon2** - Password hashing
- **jsonwebtoken (JWT)** - Session token management
- **Tailwind CSS** - Styling framework
- **Flowbite** - UI component library

### ➕ New Technologies

No new technologies introduced in this feature. All required technologies already approved in tech-stack.md v1.0.0.

### ⚠️ Conflicting Technologies

No conflicts detected.

### ❌ Prohibited Technologies

No prohibited technologies used.

**Tech Stack Status:** ✅ COMPLIANT - Ready to proceed

---

## Constitution Compliance Check

Before proceeding, verify this plan complies with ALL principles in `/memory/constitution.md`:

- [x] **Principle 1 (Functional Programming):** All authentication logic implemented as pure functions (hashPassword, verifyPassword, generateToken, verifyToken). No classes except for third-party library integration. Factory functions for session management.

- [x] **Principle 2 (Type Safety):** TypeScript strict mode enabled. Zod schemas defined for signup/signin requests, API responses, and form validation. All data boundaries validated.

- [x] **Principle 3 (Programmatic Routing):** Routes (/, /signup, /signin) defined in app/routes.ts with RouteConfig array. No file-based routing. Loaders redirect authenticated users, actions handle form submissions.

- [x] **Principle 4 (Security-First):** Passwords hashed with @node-rs/argon2. JWT stored in httpOnly cookies (never localStorage). Input validation with Zod on client and server. Parameterized database queries. Authentication middleware on protected routes.

- [x] **Principle 5 (Modern React):** Functional components only (SignupForm, SigninForm, SignoutButton). Form submission via React Router actions. No useEffect for data fetching. Hooks for local state (form validation errors).

**Compliance Notes:**
- Session management uses factory function pattern (createSession, destroySession) rather than Session class
- JWT library usage acceptable (third-party API)
- All security requirements from constitution strictly followed

---

## Overview

**Goal:** Enable users to create accounts, sign in securely, and manage their sessions to access protected features of the Tweeter platform.

**User Value:**
- New users can join the platform quickly and securely
- Returning users can access their accounts seamlessly
- Users have control over session termination for security
- Platform can identify users for personalized features

**Scope:**
- **Included:** Signup (username, email, password), signin (email, password), signout, session persistence, form validation, password security, route protection
- **Excluded:** OAuth/social login, 2FA, email verification, password reset, account deletion, username changes

---

## Technical Approach

### Architecture

**Functional Architecture Pattern:**

```
User Input → Zod Validation (client) → React Router Action
                ↓
          Zod Validation (server) → Pure Function Logic
                ↓
          Database Query (parameterized) → Result
                ↓
          Session Management (factory) → Response + Cookie
```

**Key Architectural Decisions:**

1. **Pure Function Authentication Logic:**
   - `hashPassword(password: string): Promise<string>` - argon2 hashing
   - `verifyPassword(hash: string, password: string): Promise<boolean>` - verification
   - `generateToken(userId: string): string` - JWT creation
   - `verifyToken(token: string): { userId: string } | null` - JWT validation

2. **Session Management via Factory Functions:**
   - `createSession(userId: string): { token: string, cookie: Cookie}` - creates session
   - `destroySession(token: string): void` - invalidates session
   - No Session class, all stateless functions

3. **Data Flow:**
   - Client: Form → Zod validation → Action submission
   - Server: Action → Zod validation → Auth function → DB query → Session creation → Response
   - Loader: Check session → Redirect if needed

4. **Component Composition:**
   - Page components compose form components
   - Forms use controlled inputs with validation hooks
   - No prop drilling (session from loader, actions from framework)

### Data Model Changes

**Database Changes:**
- [x] New table: `profiles` (users table for authentication)
- [x] Migration needed: Initial migration to create profiles table
- [x] Indexes: Unique on username, unique on email, index on created_at

**Type Definitions:**
```typescript
// Application layer (camelCase)
interface User {
  id: string;              // UUID v7
  username: string;        // 3-20 chars, alphanumeric + hyphen/underscore
  email: string;           // Valid email
  passwordHash: string;    // argon2 hash, never exposed in API
  bio: string | null;      // For future profile feature
  avatarUrl: string | null; // For future profile feature
  createdAt: Date;
}

// Public user data (safe for API responses)
interface PublicUser {
  id: string;
  username: string;
  email: string;
  createdAt: Date;
}

// Session data
interface SessionData {
  userId: string;
  username: string;
  email: string;
}
```

**Zod Schemas:**
```typescript
// Signup request validation
const signupSchema = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be at most 20 characters')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Username can only contain letters, numbers, hyphens, and underscores'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters')
});

// Signin request validation
const signinSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required')
});

// API response schemas
const publicUserSchema = z.object({
  id: z.string().uuid(),
  username: z.string(),
  email: z.string().email(),
  createdAt: z.string().datetime()
});

const authResponseSchema = z.object({
  user: publicUserSchema
});

const errorResponseSchema = z.object({
  error: z.string(),
  field: z.string().optional()
});
```

### API Design

**New Endpoints:**

- `POST /api/auth/signup` - Create new user account
  - Request: signupSchema (username, email, password)
  - Response: authResponseSchema (user data) + Set-Cookie header
  - Auth: Public
  - Logic: Validate → Check uniqueness → Hash password → Insert user → Generate token → Set cookie

- `POST /api/auth/signin` - Authenticate existing user
  - Request: signinSchema (email, password)
  - Response: authResponseSchema (user data) + Set-Cookie header
  - Auth: Public
  - Logic: Validate → Find user → Verify password → Generate token → Set cookie

- `POST /api/auth/signout` - Terminate user session
  - Request: None
  - Response: { success: true }
  - Auth: Required (JWT in cookie)
  - Logic: Verify token → Clear cookie → Return success

**Modified Endpoints:**
- None (first feature, no existing endpoints)

### Frontend Components

**New Components:**

- `SignupForm` - Functional component for account creation
  - Props: None (uses React Router action)
  - State: Form fields (username, email, password), validation errors
  - Hooks: useState for fields, custom useFormValidation for real-time validation
  - Behavior: Controlled inputs, client-side Zod validation, submit via form action
  - Composition: Renders input fields, validation messages, submit button

- `SigninForm` - Functional component for authentication
  - Props: None (uses React Router action)
  - State: Form fields (email, password), validation errors
  - Hooks: useState for fields
  - Behavior: Controlled inputs, client-side Zod validation, submit via form action
  - Composition: Renders input fields, error messages, submit button

- `SignoutButton` - Functional component for session termination
  - Props: None (uses React Router action)
  - State: None
  - Behavior: Form with hidden fields, submits signout action on click
  - Composition: Simple button triggering form submission

- `LandingPage` - Page component for unauthenticated users
  - Props: None
  - State: None
  - Behavior: Displays hero content, links to signup/signin
  - Composition: Hero section, CTA buttons

**Modified Components:**
- None (first feature)

**Routing Changes:**
```typescript
// app/routes.ts additions
import { RouteConfig } from '@react-router/dev/routes';

const routes: RouteConfig[] = [
  {
    path: '/',
    Component: lazy(() => import('./pages/Landing')),
    loader: landingLoader  // Redirect to /feed if authenticated
  },
  {
    path: '/signup',
    Component: lazy(() => import('./pages/Signup')),
    action: signupAction,
    loader: authPageLoader  // Redirect to /feed if authenticated
  },
  {
    path: '/signin',
    Component: lazy(() => import('./pages/Signin')),
    action: signinAction,
    loader: authPageLoader  // Redirect to /feed if authenticated
  },
  {
    path: '/feed',
    Component: lazy(() => import('./pages/Feed')),
    loader: feedLoader  // Redirect to /signin if not authenticated
  }
];

export default routes;
```

### State Management

**Server State (via React Router):**
- Session data loaded via root loader, available throughout app
- Authentication actions handle signup/signin mutations
- No client-side session management (all server-side)

**Local State (via hooks):**
- Form input values (useState)
- Validation errors (useState)
- No global state needed (session from server)

**Form State:**
- Controlled components with React Router forms
- Validation state managed locally
- Submission via framework actions (not useEffect)

**No Redux or Context needed** - React Router loaders/actions handle all server state

---

## Security Considerations

- [x] **Input validation with Zod:**
  - Client-side: Immediate feedback, prevents bad submissions
  - Server-side: Security enforcement, prevents malicious data
  - Both layers validated with same Zod schemas

- [x] **Authentication requirements:**
  - Signup/signin endpoints are public
  - Signout endpoint requires valid JWT
  - Protected routes (feed, profile, settings) require authentication

- [x] **Authorization checks:**
  - Authentication middleware verifies JWT on protected routes
  - Middleware extracts userId from token for request context
  - Invalid/expired tokens redirect to signin

- [x] **No sensitive data in localStorage/client state:**
  - JWT stored in httpOnly cookie (inaccessible to JavaScript)
  - Password never sent to client after signup
  - Email/username public, no sensitive personal data yet

- [x] **Parameterized database queries:**
  - All queries use postgres parameterized syntax: sql`SELECT * FROM profiles WHERE email = ${email}`
  - No string concatenation in queries
  - Prevents SQL injection attacks

**Additional Security Measures:**
- Password hashing uses argon2 with recommended work factors
- Cookie configuration: httpOnly, secure (production), sameSite: 'lax'
- Generic error messages on signin (prevents user enumeration)
- Timing-constant password comparison via argon2
- Session expiration: 30 days (configurable)

---

## Testing Strategy

**Unit Tests:**
- [x] `hashPassword()` function: generates valid argon2 hash
- [x] `verifyPassword()` function: correctly verifies hashes
- [x] `generateToken()` function: creates valid JWT
- [x] `verifyToken()` function: validates JWT and extracts userId
- [x] Zod schemas: validate correct inputs, reject invalid inputs
- [x] Form components: render correctly, display validation errors

**Integration Tests:**
- [x] POST /api/auth/signup with valid data → 200, user created, cookie set
- [x] POST /api/auth/signup with duplicate username → 409 conflict
- [x] POST /api/auth/signup with duplicate email → 409 conflict
- [x] POST /api/auth/signup with invalid data → 400 validation error
- [x] POST /api/auth/signin with valid credentials → 200, cookie set
- [x] POST /api/auth/signin with invalid credentials → 401 unauthorized
- [x] POST /api/auth/signout with valid token → 200, cookie cleared
- [x] POST /api/auth/signout without token → 401 unauthorized
- [x] Protected route access without auth → redirect to signin
- [x] Protected route access with auth → allowed

**End-to-End Tests:**
- [x] Complete signup flow: fill form → submit → redirect to feed → session persists
- [x] Complete signin flow: fill form → submit → redirect to feed → session persists
- [x] Complete signout flow: click signout → redirect to landing → cannot access protected routes
- [x] Session persistence: reload page while authenticated → still authenticated
- [x] Form validation: enter invalid data → see errors → correct → submit successfully
- [x] Duplicate account prevention: signup with existing username → error displayed

**Manual Testing:**
- [x] Test on Chrome, Firefox, Safari
- [x] Test cookie behavior (inspect cookies, verify httpOnly)
- [x] Test session expiration (manually expire JWT, verify redirect)
- [x] Test protected route access (direct URL navigation while unauthenticated)
- [x] Test error messages (clear, actionable, not exposing security details)

---

## Implementation Phases

### Phase 1: Database & Pure Functions (Foundation)

**Tasks:**
1. Create PostgreSQL database connection module (pure function: `createDbConnection()`)
2. Write database migration for profiles table (SQL script)
3. Implement password hashing functions (`hashPassword`, `verifyPassword`) using argon2
4. Implement JWT functions (`generateToken`, `verifyToken`) using jsonwebtoken
5. Write unit tests for all pure functions

**Deliverables:**
- Database schema created and migrated
- Password hashing working and tested
- JWT generation/verification working and tested
- All unit tests passing

### Phase 2: API Endpoints (Backend)

**Tasks:**
1. Create Express server with TypeScript configuration
2. Implement POST /api/auth/signup endpoint
   - Zod validation middleware
   - Check username/email uniqueness
   - Hash password
   - Insert user into database
   - Generate JWT and set cookie
3. Implement POST /api/auth/signin endpoint
   - Zod validation middleware
   - Find user by email
   - Verify password
   - Generate JWT and set cookie
4. Implement POST /api/auth/signout endpoint
   - Authentication middleware (verify JWT)
   - Clear cookie
5. Implement authentication middleware (JWT verification)
6. Write integration tests for all endpoints

**Deliverables:**
- All auth API endpoints functional
- Authentication middleware working
- Integration tests passing
- Postman/Thunder Client collection for manual testing

### Phase 3: Frontend Components (UI)

**Tasks:**
1. Set up React Router v7 project with TypeScript
2. Configure app/routes.ts with programmatic routing
3. Implement Landing page component
4. Implement Signup page with SignupForm component
   - Controlled inputs with useState
   - Client-side Zod validation
   - Error display
   - React Router action integration
5. Implement Signin page with SigninForm component
   - Similar to Signup
6. Implement SignoutButton component
7. Style all components with Tailwind CSS + Flowbite
8. Write component tests (React Testing Library)

**Deliverables:**
- All page and form components implemented
- Forms styled with Tailwind CSS
- Client-side validation working
- Component tests passing

### Phase 4: Integration & Loaders (Glue)

**Tasks:**
1. Implement signup action (connect form to API)
2. Implement signin action (connect form to API)
3. Implement signout action (connect button to API)
4. Implement loaders:
   - Landing loader (redirect if authenticated)
   - Auth page loader (redirect if authenticated)
   - Feed loader (redirect if not authenticated)
5. Implement root loader (load session data for app)
6. Configure cookie parsing in server
7. Write end-to-end tests

**Deliverables:**
- Full authentication flow working end-to-end
- Session persistence across page reloads
- Protected routes redirecting correctly
- E2E tests passing

### Phase 5: Polish & Documentation

**Tasks:**
1. Add loading states to forms
2. Improve error messages (user-friendly, actionable)
3. Add accessibility attributes (ARIA labels, keyboard nav)
4. Write API documentation (endpoints, schemas, examples)
5. Update CLAUDE.md with authentication patterns
6. Write deployment notes (environment variables, database setup)

**Deliverables:**
- UX polished and accessible
- Documentation complete
- Feature ready for deployment

---

## Dependencies

**External Dependencies:**
- [x] PostgreSQL database (Neon) - Required before Phase 1
- [x] Neon connection string - Required before Phase 1
- [x] Node.js environment (v20+) - Required for development

**Internal Dependencies:**
- None (first feature, no prerequisites)

**Blockers:**
- None

**Environment Variables Needed:**
```
DATABASE_URL=postgresql://[user]:[password]@[host]/[database]
JWT_SECRET=[random-secret-key]  # Generate with crypto.randomBytes(64).toString('hex')
NODE_ENV=development|production
COOKIE_DOMAIN=localhost|yourdomain.com
```

---

## Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| JWT secret compromise | High | Low | Store in environment variable, rotate periodically, never commit to repo |
| Password hash weakness | High | Low | Use argon2 with recommended settings, test with password strength tools |
| Session hijacking | Medium | Medium | Use httpOnly cookies, secure flag in production, sameSite attribute |
| Database connection failure | High | Low | Implement connection retry logic, health check endpoint |
| Zod validation mismatch (client vs server) | Medium | Medium | Use shared Zod schemas via monorepo or package, integration tests verify both |
| User enumeration via timing | Low | Medium | Use timing-constant comparison, generic error messages |

---

## Success Criteria

- [x] Feature works as specified (all user stories met)
- [x] All tests pass (unit, integration, E2E)
- [x] Constitution principles followed (checklist above verified)
- [x] No TypeScript errors (strict mode passes)
- [x] No security vulnerabilities (OWASP checklist passed)
- [x] Code reviewed and approved
- [x] Users can signup in under 60 seconds
- [x] Session persistence: 100% reliability across refreshes
- [x] Password security: argon2 hash generation < 500ms

---

## Rollback Plan

**If critical issues found post-deployment:**

1. **Immediate:** Disable signup/signin endpoints (return 503)
2. **Preserve data:** Do NOT drop profiles table (users already created)
3. **Fix forward:** Patch issue and redeploy (preferred over rollback)
4. **If rollback needed:**
   - Revert backend code to previous commit
   - Keep database schema (no destructive rollback)
   - Re-enable endpoints after verification

**Rollback Testing:**
- Test rollback procedure in staging before production
- Document rollback steps in runbook
- Ensure database migrations are reversible

---

## Documentation Updates

- [x] API documentation: Document all 3 auth endpoints with schemas and examples
- [x] User-facing documentation: Write "Getting Started" guide for signup/signin
- [x] Developer documentation: Document authentication middleware usage, JWT structure
- [x] CLAUDE.md updates: Add authentication patterns section, session management notes

---

## Notes

**Architecture Decision Records:**

1. **Why argon2 over bcrypt?**
   - Argon2 is more resistant to GPU attacks
   - Recommended by OWASP
   - @node-rs/argon2 is fast native implementation

2. **Why JWT in httpOnly cookies instead of localStorage?**
   - httpOnly cookies inaccessible to JavaScript (XSS protection)
   - Automatic inclusion in requests (no manual header management)
   - Constitution Principle 4 requirement

3. **Why no email verification in MVP?**
   - Reduces friction for users in initial launch
   - Can be added later without schema changes
   - Marked as P2 (Could Have) in spec

4. **Why factory functions instead of Session class?**
   - Constitution Principle 1 (Functional Programming)
   - Stateless session management more testable
   - Simpler reasoning about session lifecycle

5. **Why 30-day session expiration?**
   - Balance between security and convenience
   - Industry standard for social media platforms
   - Configurable via environment variable

**Performance Notes:**
- Password hashing intentionally slow (security > speed)
- Database queries use indexes (username, email) for fast lookups
- JWT verification cached per request (avoid redundant crypto)

**Security Review Checklist:**
- [ ] OWASP Top 10 review completed
- [ ] Penetration testing performed (or scheduled)
- [ ] Security audit of authentication flow
- [ ] Rate limiting considered (future enhancement)
