# Implementation Plan: Password Reset Flow with Email Token Verification

**Feature ID:** 915
**Created:** 2025-10-16
**Status:** draft

---

## Tech Stack Compliance Report
<!-- Auto-generated by SpecSwarm tech stack validation -->

### ✅ Approved Technologies (already in stack)
- TypeScript 5.x (strict mode)
- React Router v7 (framework mode, programmatic routing)
- Express (REST API backend)
- PostgreSQL 17 via Neon (postgres npm package)
- Zod (validation)
- @node-rs/argon2 (password hashing)
- jsonwebtoken (JWT sessions)
- Tailwind CSS + Flowbite (UI)
- uuid (uuidv7)

### ➕ New Technologies (auto-added)
- **mailgun.js v10.x**
  - Purpose: Email delivery API client
  - No conflicts detected
  - Added to: External Services section
  - Justification: Secure, reliable email delivery for password reset flow
  - Free tier: 5,000 emails/month
  - Auto-added to tech-stack.md version 1.3.0

- **@types/mailgun.js**
  - Purpose: TypeScript definitions for mailgun.js
  - No conflicts detected
  - Added to: Dev Dependencies section
  - Auto-added to tech-stack.md version 1.3.0

### ⚠️ Conflicting Technologies
None detected.

### ❌ Prohibited Technologies
None used. All technologies comply with tech-stack.md and constitution.md.

---

## Constitution Compliance Check

Before proceeding, verify this plan complies with ALL principles in `/memory/constitution.md`:

- [x] **Principle 1 (Functional Programming):** Design uses pure functions for token generation, email sending, password hashing. No classes except Mailgun API client (third-party requirement).
- [x] **Principle 2 (Type Safety):** All boundaries have TypeScript types + Zod schemas (email validation, password strength, token format).
- [x] **Principle 3 (Programmatic Routing):** Routes `/forgot-password` and `/reset-password/:token` defined in app/routes.ts only.
- [x] **Principle 4 (Security-First):** Tokens hashed before storage, rate limiting, no email enumeration, argon2 password hashing, single-use tokens.
- [x] **Principle 5 (Modern React):** Functional components with hooks, React Router loaders for token validation, actions for form submission.

**Compliance Notes:**
- Mailgun API client uses classes internally (third-party library - exception allowed per Principle 1)
- All custom code (token generation, validation, password reset) uses pure functions
- Security measures exceed OWASP recommendations (token hashing, rate limiting, expiration)

---

## Overview

**Goal:** Enable users who have forgotten their password to securely reset it via an email-based verification flow with time-limited, single-use tokens.

**User Value:**
- Users regain access to locked accounts without support intervention
- Secure process prevents unauthorized password changes
- Clear UX guides users through reset flow

**Scope:**
- **Included:**
  - Request password reset form (/forgot-password)
  - Email delivery with reset link
  - Token validation and password reset form (/reset-password/:token)
  - Rate limiting (3 requests/email/hour)
  - Security notifications after password change

- **Excluded:**
  - SMS-based reset
  - Security questions
  - Account recovery without email
  - Multi-factor authentication

---

## Technical Approach

### Architecture

**High-Level Flow:**
```
User → /forgot-password form → POST /api/auth/forgot-password
                                  ↓
                         Generate token (uuidv7)
                         Hash token (sha256)
                         Store in password_reset_tokens table
                         Send email via Mailgun
                                  ↓
User clicks email link → GET /reset-password/:token → Loader validates token
                                  ↓
                         If valid: Show password reset form
                         If invalid: Show error + link to request new
                                  ↓
User submits new password → POST /api/auth/reset-password
                                  ↓
                         Validate password strength (Zod)
                         Hash password (argon2)
                         Update profiles table
                         Mark token as used
                         Create session (JWT)
                         Send confirmation email
                                  ↓
                         Redirect to /feed (user signed in)
```

**Functional Design:**
- Pure functions for token operations: `generateResetToken()`, `hashToken()`, `validateToken()`, `markTokenUsed()`
- Pure function for email: `sendPasswordResetEmail(email, token)`, `sendPasswordChangedEmail(email)`
- Rate limiting function: `checkRateLimit(email): boolean`
- All database operations via parameterized queries

### Data Model Changes

**Database Changes:**
- [x] New table: `password_reset_tokens`
- [x] Migration needed: `001_create_password_reset_tokens_table.sql`
- [x] Indexes: token_hash, profile_id, expires_at

**SQL Schema:**
```sql
CREATE TABLE password_reset_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  token_hash VARCHAR(255) NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_password_reset_tokens_token_hash ON password_reset_tokens(token_hash);
CREATE INDEX idx_password_reset_tokens_profile_id ON password_reset_tokens(profile_id);
CREATE INDEX idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);
```

**Type Definitions:**
```typescript
// Application layer (camelCase)
interface PasswordResetToken {
  id: string;
  profileId: string;
  tokenHash: string;
  expiresAt: Date;
  usedAt: Date | null;
  createdAt: Date;
}

interface ForgotPasswordRequest {
  email: string;
}

interface ResetPasswordRequest {
  token: string;
  password: string;
}

interface TokenValidationResult {
  valid: boolean;
  email?: string;
  error?: string;
}
```

**Zod Schemas:**
```typescript
// Request validation
const forgotPasswordSchema = z.object({
  email: z.string().email("Invalid email format").toLowerCase(),
});

const resetPasswordSchema = z.object({
  token: z.string().uuid("Invalid token format"),
  password: z.string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
    .regex(/[a-z]/, "Password must contain at least one lowercase letter")
    .regex(/[0-9]/, "Password must contain at least one number"),
});

// Response validation
const tokenValidationSchema = z.object({
  valid: z.boolean(),
  email: z.string().email().optional(),
});
```

### API Design

**New Endpoints:**

1. `POST /api/auth/forgot-password` - Initiate password reset
   - Request: `forgotPasswordSchema`
   - Response: `{ message: string }` (generic success)
   - Auth: Public
   - Logic:
     - Validate email format
     - Check rate limit (max 3/hour per email)
     - If email exists: generate token, send email
     - If email not exists: silent success (no enumeration)
     - Always return same success message

2. `GET /api/auth/verify-reset-token/:token` - Validate token (used by loader)
   - Request: URL param `token`
   - Response: `tokenValidationSchema`
   - Auth: Public (token is credential)
   - Logic:
     - Hash provided token
     - Query database for matching hash
     - Check expiration (1 hour)
     - Check if already used
     - Return validation result

3. `POST /api/auth/reset-password` - Reset password with token
   - Request: `resetPasswordSchema`
   - Response: `{ success: boolean, message: string }`
   - Auth: Token-based (token in request body)
   - Logic:
     - Validate password strength (Zod)
     - Verify token (same as verify endpoint)
     - Hash new password (argon2)
     - Update profiles.password_hash
     - Mark token as used
     - Create JWT session
     - Send confirmation email
     - Return success

**Modified Endpoints:**
None (all new endpoints)

### Frontend Components

**New Components:**

1. **ForgotPasswordForm** - `/app/components/ForgotPasswordForm.tsx`
   - Purpose: Email input form for password reset request
   - Props: `{ action?: string }` (defaults to /api/auth/forgot-password)
   - State: `loading` (boolean), `submitted` (boolean)
   - Hooks: `useActionData()` for form response
   - Behavior:
     - Email validation on blur (Zod schema)
     - Submit disables during loading
     - Shows success message after submission
     - Generic message prevents email enumeration

2. **ResetPasswordForm** - `/app/components/ResetPasswordForm.tsx`
   - Purpose: New password input form
   - Props: `{ token: string, email: string }`
   - State: `password` (string), `confirmPassword` (string), `showPassword` (boolean), `loading` (boolean)
   - Hooks: `useActionData()`, `useState()`, `useNavigate()`
   - Behavior:
     - Real-time password strength indicator
     - Password match validation
     - Show/hide password toggle
     - Submit redirects to /feed on success

3. **ForgotPasswordPage** - `/app/routes/forgot-password.tsx`
   - Purpose: Page component for /forgot-password route
   - Uses ForgotPasswordForm component
   - Action: handles form submission

4. **ResetPasswordPage** - `/app/routes/reset-password.$token.tsx`
   - Purpose: Page component for /reset-password/:token route
   - Loader: validates token via API
   - Uses ResetPasswordForm component
   - Action: handles password reset submission

**Modified Components:**

- **SignInPage** - Add "Forgot password?" link
  - Location: `/app/routes/signin.tsx`
  - Add link below password input: `<Link to="/forgot-password">Forgot password?</Link>`

**Routing Changes:**
```typescript
// app/routes.ts additions
import { ForgotPasswordPage } from './routes/forgot-password';
import { ResetPasswordPage } from './routes/reset-password.$token';

export const routes: RouteConfig[] = [
  // ... existing routes
  {
    path: '/forgot-password',
    Component: ForgotPasswordPage,
    action: forgotPasswordAction,
  },
  {
    path: '/reset-password/:token',
    Component: ResetPasswordPage,
    loader: resetPasswordLoader,
    action: resetPasswordAction,
  },
];
```

### State Management

**Server State (via loaders):**
- Token validation result (loader in /reset-password/:token)
- User profile (after successful reset, signed in via JWT)

**Form State (controlled components):**
- Email input (ForgotPasswordForm)
- Password + confirm password (ResetPasswordForm)
- Password visibility toggle

**Loading States:**
- Form submission loading (React Router useNavigation)
- Action data for success/error messages (useActionData)

**No client-side state management needed** - all state managed via:
1. React Router loaders (server data)
2. React Router actions (form submissions)
3. Local component state (form inputs, UI toggles)

---

## Security Considerations

- [x] **Input validation**: Zod schemas on client (UX) and server (security)
- [x] **Authentication**: Token acts as temporary credential; JWT created after successful reset
- [x] **Authorization**: Token grants access only to reset specific user's password
- [x] **No email enumeration**: Generic success message for all reset requests
- [x] **Token security**:
  - Generated with crypto.randomUUID() (128-bit entropy)
  - Hashed before database storage (sha256)
  - 1-hour expiration
  - Single-use (marked as used after reset)
- [x] **Rate limiting**:
  - Max 3 reset requests per email per hour
  - Stored in database (password_reset_rate_limits table)
  - Returns 429 status when exceeded
- [x] **Password strength**: Zod validation enforces min 8 chars, upper, lower, number
- [x] **SQL injection prevention**: Parameterized queries via postgres package
- [x] **XSS prevention**: React automatic escaping + Zod email validation
- [x] **Session creation**: JWT in httpOnly cookie after successful reset

**Additional Security Measures:**
- Confirmation email sent after password change (alerts user if unauthorized)
- HTTPS-only reset links in production
- Token cleanup job removes expired tokens (prevents database bloat)

---

## Testing Strategy

**Unit Tests:**
- [x] `generateResetToken()` - creates valid uuidv7
- [x] `hashToken()` - produces consistent hashes
- [x] `isTokenExpired()` - correctly validates expiration
- [x] `isTokenUsed()` - correctly checks used_at field
- [x] `checkRateLimit()` - enforces 3 requests/hour limit
- [x] Zod schemas - validate all valid/invalid inputs
- [x] Password strength regex - accepts strong, rejects weak passwords

**Integration Tests:**
- [x] POST /api/auth/forgot-password - returns success for valid email
- [x] POST /api/auth/forgot-password - returns success for invalid email (no enumeration)
- [x] POST /api/auth/forgot-password - respects rate limits (4th request fails)
- [x] GET /api/auth/verify-reset-token/:token - validates unexpired token
- [x] GET /api/auth/verify-reset-token/:token - rejects expired token
- [x] POST /api/auth/reset-password - successfully resets password
- [x] POST /api/auth/reset-password - rejects used token
- [x] POST /api/auth/reset-password - creates session (JWT cookie set)
- [x] Email delivery - Mailgun API called with correct params

**End-to-End Tests:**
- [x] Full flow: request → email → reset → signin
- [x] Expired token shows error message
- [x] Used token shows error message
- [x] Invalid token shows error message
- [x] Rate limit prevents abuse
- [x] Confirmation email sent after password change

**Manual Testing Checklist:**
- [ ] User can complete password reset flow
- [ ] Email arrives within 1 minute
- [ ] Reset link expires after 1 hour
- [ ] Used token cannot be reused
- [ ] Rate limiting works (try 4 requests rapidly)
- [ ] Strong password required
- [ ] Weak password rejected with clear message
- [ ] User auto-signed in after reset
- [ ] Confirmation email sent

---

## Implementation Phases

### Phase 1: Database Schema & Backend Core
**Tasks:**
1. Create migration: `001_create_password_reset_tokens_table.sql`
2. Create migration: `002_create_password_reset_rate_limits_table.sql`
3. Implement pure functions in `server/utils/password-reset.ts`:
   - `generateResetToken(): string`
   - `hashToken(token: string): string`
   - `checkRateLimit(email: string): Promise<boolean>`
   - `recordResetRequest(email: string): Promise<void>`
4. Configure Mailgun client in `server/services/email.ts`:
   - `initMailgun(): FormData` (factory function)
   - `sendPasswordResetEmail(email: string, token: string): Promise<void>`
   - `sendPasswordChangedEmail(email: string): Promise<void>`
5. Create Zod schemas in `server/schemas/auth.ts`
6. Write unit tests for all pure functions

**Deliverables:**
- Migrations run successfully
- Pure functions tested and working
- Mailgun configured (test with sandbox domain)

### Phase 2: API Endpoints
**Tasks:**
1. Implement `POST /api/auth/forgot-password` in `server/routes/auth.ts`
   - Validate request with Zod
   - Check rate limit
   - Generate and store token (if email valid)
   - Send email
   - Return generic success
2. Implement `GET /api/auth/verify-reset-token/:token`
   - Validate token format
   - Check database (hashed token)
   - Verify expiration and usage
   - Return validation result
3. Implement `POST /api/auth/reset-password`
   - Validate request with Zod
   - Verify token
   - Hash password with argon2
   - Update database
   - Mark token as used
   - Create JWT session
   - Send confirmation email
4. Write integration tests for all endpoints
5. Test with Postman/curl

**Deliverables:**
- All endpoints functional
- Integration tests passing
- API ready for frontend integration

### Phase 3: Frontend UI
**Tasks:**
1. Create `ForgotPasswordForm` component
   - Email input with Zod validation
   - Loading state
   - Success message display
2. Create `ForgotPasswordPage` route component
   - Integrate ForgotPasswordForm
   - Implement action function
3. Create `ResetPasswordForm` component
   - Password + confirm password inputs
   - Password strength indicator
   - Show/hide toggle
   - Match validation
4. Create `ResetPasswordPage` route component
   - Implement loader (token validation)
   - Integrate ResetPasswordForm
   - Implement action function
   - Handle error states (expired, invalid, used)
5. Add "Forgot password?" link to SignInPage
6. Add routes to `app/routes.ts`
7. Style with Tailwind + Flowbite
8. Write component tests (React Testing Library)

**Deliverables:**
- All UI components implemented
- Routes configured in app/routes.ts
- Components tested
- Styling complete

### Phase 4: Integration & Testing
**Tasks:**
1. End-to-end testing
   - Test full flow in browser
   - Verify emails sent and received
   - Test all error scenarios
2. Security testing
   - Verify no email enumeration
   - Test rate limiting
   - Verify token security (hashing, expiration, single-use)
   - Test password strength requirements
3. Performance testing
   - Database query performance (check indexes)
   - Email sending performance
4. Accessibility testing
   - Keyboard navigation
   - Screen reader testing
   - ARIA labels
5. Fix bugs and edge cases
6. Documentation updates

**Deliverables:**
- Feature fully functional
- All tests passing
- Security verified
- Documentation complete

---

## Dependencies

**External Dependencies:**
- [x] Mailgun account and domain verification
  - Reason: Email delivery service
  - Status: Required (user must configure MAILGUN_API_KEY, MAILGUN_DOMAIN)
  - Docs: https://documentation.mailgun.com/en/latest/quickstart.html

- [x] mailgun.js npm package v10.x
  - Reason: Official Mailgun Node.js SDK
  - Status: Will be installed in Phase 1

**Internal Dependencies:**
- [x] Existing authentication system (JWT in httpOnly cookies)
  - Reason: Create session after password reset
  - Status: Already implemented (feature 001)

- [x] Profiles table with email and password_hash
  - Reason: Store password and lookup by email
  - Status: Already exists

**Blockers:**
- [ ] Mailgun account setup and API credentials
  - **Action Required**: User must create Mailgun account and add credentials to .env
  - **Timeline**: Can use Mailgun sandbox for development/testing
  - **Production**: Verify domain before sending to real addresses

---

## Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Email delivery failure (Mailgun downtime) | High | Low | Use Mailgun's free tier for testing; consider fallback SMTP provider in future; log email failures for manual follow-up |
| Token leakage via email interception | Medium | Low | 1-hour expiration minimizes window; single-use tokens prevent reuse; HTTPS-only links |
| Rate limit bypass via multiple emails | Medium | Medium | Implement additional IP-based rate limiting (10 requests/hour per IP) in Phase 2 |
| Database bloat from expired tokens | Low | High | Background job to cleanup tokens older than 24 hours; runs daily via cron |
| User forgets which email they used | Low | High | Clear error messaging; suggest common email patterns; support contact info |

---

## Success Criteria

- [x] Users can complete password reset in under 2 minutes
- [x] 100% of valid reset requests result in email delivery
- [x] 0 email enumeration vulnerabilities (same message for valid/invalid)
- [x] Rate limiting prevents abuse (max 3 requests/email/hour enforced)
- [x] Tokens expire after 1 hour (verified in tests)
- [x] Tokens are single-use (cannot reuse after password reset)
- [x] All unit tests pass (>90% coverage for password-reset.ts)
- [x] All integration tests pass
- [x] All E2E tests pass
- [x] No TypeScript errors
- [x] Constitution compliance verified
- [x] Security audit passes (no OWASP violations)
- [x] Accessibility audit passes (WCAG 2.1 AA)

---

## Rollback Plan

**If issues arise post-deployment:**

1. **Immediate rollback** (< 5 minutes):
   ```bash
   git revert <feature-commit-hash>
   git push
   # Redeploy
   ```

2. **Database rollback** (if migrations cause issues):
   ```sql
   -- Rollback migration
   DROP TABLE IF EXISTS password_reset_tokens;
   DROP TABLE IF EXISTS password_reset_rate_limits;
   ```

3. **Route removal** (disable feature without full rollback):
   - Comment out /forgot-password and /reset-password routes in app/routes.ts
   - Remove "Forgot password?" link from signin page
   - Redeploy (feature invisible to users)

4. **Data cleanup** (if needed after rollback):
   - Tokens table can be safely dropped (no foreign key dependencies from other tables)
   - Rate limits table can be safely dropped

**No data loss** - Users can continue using accounts normally even if password reset is disabled.

---

## Documentation Updates

- [x] **API documentation** (`docs/api.md`)
  - Add new endpoints: forgot-password, verify-reset-token, reset-password
  - Include request/response examples
  - Document error codes

- [x] **User-facing documentation** (`docs/password-reset.md`)
  - How to reset password
  - What to do if email doesn't arrive
  - Security best practices

- [x] **Developer documentation** (`docs/dev/password-reset.md`)
  - Architecture overview
  - Token lifecycle
  - Email configuration (Mailgun setup)
  - Testing guide

- [x] **CLAUDE.md updates**
  - Add password reset endpoints to API section
  - Add /forgot-password and /reset-password to routes list
  - Document Mailgun integration in tech stack

- [x] **.env.example** - Add Mailgun variables:
  ```
  MAILGUN_API_KEY=your_mailgun_api_key
  MAILGUN_DOMAIN=mg.yourdomain.com
  ```

---

## Notes

**Design Decisions:**

1. **Token hashing vs encryption:**
   - Using sha256 hash (one-way) instead of encryption
   - Rationale: No need to decrypt token; only need to verify match
   - Even if database leaked, tokens are unusable

2. **Database-based rate limiting:**
   - Chose database over Redis for simplicity
   - Rationale: Tweeter is low-traffic; database is sufficient
   - Future: Can migrate to Redis if performance issues arise

3. **1-hour token expiration:**
   - Industry standard (OWASP recommendation: 15 min - 1 hour)
   - Balances security (shorter = more secure) vs UX (longer = more convenient)

4. **Generic success message:**
   - Critical security measure to prevent email enumeration
   - Requirement from OWASP Forgot Password Cheat Sheet

5. **Mailgun over SMTP:**
   - Better deliverability (dedicated IPs, reputation management)
   - Detailed analytics and logging
   - Free tier sufficient for development and early production

**Future Enhancements:**
- SMS-based password reset (alternative to email)
- Multi-factor authentication (require MFA before showing reset form)
- Account lockout after N failed reset attempts
- Admin dashboard to view reset request metrics
- Password reset history log (security audit trail)

**References:**
- OWASP Forgot Password Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html
- Mailgun API Documentation: https://documentation.mailgun.com/en/latest/
- React Router v7 Loaders/Actions: https://reactrouter.com/en/main/route/loader
